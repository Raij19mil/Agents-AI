import os
import re
import pathlib
import time
from typing import TypedDict, Optional, List, Dict, Literal
from pathlib import Path
from threading import Thread
from flask import Flask, request, jsonify, render_template_string

# LangChain imports
from langchain_google_genai import ChatGoogleGenerativeAI, GoogleGenerativeAIEmbeddings
from langchain_community.document_loaders import PyMuPDFLoader
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import FAISS
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import SystemMessage, HumanMessage
from langchain.chains.combine_documents import create_stuff_documents_chain

# LangGraph imports
from langgraph.graph import StateGraph, START, END

# Pydantic imports
from pydantic import BaseModel, Field

app = Flask(__name__)

class ServiceDeskAgent:
    def __init__(self, google_api_key: str, documents_path: str = "./documents/"):
        """
        Initialize the Service Desk Agent
        
        Args:
            google_api_key: Google API key for Gemini models
            documents_path: Path to directory containing PDF policy documents
        """
        self.google_api_key = google_api_key
        self.documents_path = documents_path
        
        # Initialize LLMs
        self.llm_triagem = ChatGoogleGenerativeAI(
            model="gemini-2.5-flash",
            temperature=0.0,
            api_key=google_api_key
        )
        
        self.embeddings = GoogleGenerativeAIEmbeddings(
            model="models/gemini-embedding-001",
            google_api_key=google_api_key
        )
        
        # Initialize components
        self.vectorstore = None
        self.retriever = None
        self.document_chain = None
        self.triagem_chain = None
        self.workflow = None
        self.ativo = True
        
        self._setup_triagem()
        self._setup_rag()
        self._setup_workflow()
    
    def _setup_triagem(self):
        """Setup the triage system"""
        
        # Triagem prompt
        self.TRIAGEM_PROMPT = (
            "Você é um triador de Service Desk para políticas internas da empresa Carraro Desenvolvimento. "
            "Dada a mensagem do usuário, retorne SOMENTE um JSON com:\n"
            "{\n"
            '  "decisao": "AUTO_RESOLVER" | "PEDIR_INFO" | "ABRIR_CHAMADO",\n'
            '  "urgencia": "BAIXA" | "MEDIA" | "ALTA",\n'
            '  "campos_faltantes": ["..."]\n'
            "}\n"
            "Regras:\n"
            '- **AUTO_RESOLVER**: Perguntas claras sobre regras ou procedimentos descritos nas políticas (Ex: "Posso reembolsar a internet do meu home office?", "Como funciona a política de alimentação em viagens?").\n'
            '- **PEDIR_INFO**: Mensagens vagas ou que faltam informações para identificar o tema ou contexto (Ex: "Preciso de ajuda com uma política", "Tenho uma dúvida geral").\n'
            '- **ABRIR_CHAMADO**: Pedidos de exceção, liberação, aprovação ou acesso especial, ou quando o usuário explicitamente pede para abrir um chamado (Ex: "Quero exceção para trabalhar 5 dias remoto.", "Solicito liberação para anexos externos.", "Por favor, abra um chamado para o RH.").'
            "Analise a mensagem e decida a ação mais apropriada."
        )
        
        # Pydantic model for structured output
        class TriagemOut(BaseModel):
            decisao: Literal["AUTO_RESOLVER", "PEDIR_INFO", "ABRIR_CHAMADO"]
            urgencia: Literal["BAIXA", "MEDIA", "ALTA"]
            campos_faltantes: List[str] = Field(default_factory=list)
        
        self.triagem_chain = self.llm_triagem.with_structured_output(TriagemOut)
    
    def _setup_rag(self):
        """Setup RAG system with document loading and vector store"""
        
        # Load documents
        docs = self._load_documents()
        
        if not docs:
            print("Warning: No documents loaded. RAG functionality will be limited.")
            return
        
        # Split documents into chunks
        splitter = RecursiveCharacterTextSplitter(chunk_size=300, chunk_overlap=30)
        chunks = splitter.split_documents(docs)
        
        # Create vector store
        self.vectorstore = FAISS.from_documents(chunks, self.embeddings)
        self.retriever = self.vectorstore.as_retriever(
            search_type="similarity_score_threshold",
            search_kwargs={"score_threshold": 0.3, "k": 4}
        )
        
        # Create document chain for RAG
        prompt_rag = ChatPromptTemplate.from_messages([
            ("system",
             "Você é um Assistente de Políticas Internas (RH/IT) da empresa Carraro Desenvolvimento. "
             "Responda SOMENTE com base no contexto fornecido. "
             "Se não houver base suficiente, responda apenas 'Não sei'."),
            ("human", "Pergunta: {input}\n\nContexto:\n{context}")
        ])
        
        self.document_chain = create_stuff_documents_chain(self.llm_triagem, prompt_rag)
    
    def _load_documents(self):
        """Load PDF documents from the specified directory"""
        docs = []
        
        if not os.path.exists(self.documents_path):
            print(f"Documents directory {self.documents_path} does not exist.")
            return docs
        
        for pdf_file in Path(self.documents_path).glob("*.pdf"):
            try:
                loader = PyMuPDFLoader(str(pdf_file))
                docs.extend(loader.load())
                print(f"Loaded document: {pdf_file.name}")
            except Exception as e:
                print(f"Error loading {pdf_file.name}: {e}")
        
        print(f"Total documents loaded: {len(docs)}")
        return docs
    
    def _setup_workflow(self):
        """Setup the LangGraph workflow"""
        
        # State definition
        class AgentState(TypedDict, total=False):
            pergunta: str
            triagem: dict
            resposta: Optional[str]
            citacoes: List[dict]
            rag_sucesso: bool
            acao_final: str
        
        # Keywords for opening tickets
        self.KEYWORDS_ABRIR_TICKET = [
            "aprovação", "exceção", "liberação", "abrir ticket", 
            "abrir chamado", "acesso especial"
        ]
        
        # Node functions
        def node_triagem(state: AgentState) -> AgentState:
            return {"triagem": self.triagem(state["pergunta"])}
        
        def node_auto_resolver(state: AgentState) -> AgentState:
            resposta_rag = self.perguntar_politica_RAG(state["pergunta"])
            
            update: AgentState = {
                "resposta": resposta_rag["answer"],
                "citacoes": resposta_rag.get("citacoes", []),
                "rag_sucesso": resposta_rag["contexto_encontrado"],
            }
            
            if resposta_rag["contexto_encontrado"]:
                update["acao_final"] = "AUTO_RESOLVER"
            
            return update
        
        def node_pedir_info(state: AgentState) -> AgentState:
            faltantes = state["triagem"].get("campos_faltantes", [])
            if faltantes:
                detalhe = ", ".join(faltantes)
            else:
                detalhe = "Tema e contexto específico"
            
            return {
                "resposta": f"Para avançar, preciso que detalhe: {detalhe}",
                "citacoes": [],
                "acao_final": "PEDIR_INFO"
            }
        
        def node_abrir_chamado(state: AgentState) -> AgentState:
            triagem = state["triagem"]
            
            return {
                "resposta": f"Abrindo chamado com urgência {triagem['urgencia']}. Descrição: {state['pergunta'][:140]}",
                "citacoes": [],
                "acao_final": "ABRIR_CHAMADO"
            }
        
        # Decision functions
        def decidir_pos_triagem(state: AgentState) -> str:
            decisao = state["triagem"]["decisao"]
            
            if decisao == "AUTO_RESOLVER": 
                return "auto"
            if decisao == "PEDIR_INFO": 
                return "info"
            if decisao == "ABRIR_CHAMADO": 
                return "chamado"
        
        def decidir_pos_auto_resolver(state: AgentState) -> str:
            if state.get("rag_sucesso"):
                return "ok"
            
            pergunta_lower = (state["pergunta"] or "").lower()
            
            if any(k in pergunta_lower for k in self.KEYWORDS_ABRIR_TICKET):
                return "chamado"
            
            return "info"
        
        # Build workflow
        workflow = StateGraph(AgentState)
        
        # Add nodes
        workflow.add_node("triagem", node_triagem)
        workflow.add_node("auto_resolver", node_auto_resolver)
        workflow.add_node("pedir_info", node_pedir_info)
        workflow.add_node("abrir_chamado", node_abrir_chamado)
        
        # Add edges
        workflow.add_edge(START, "triagem")
        workflow.add_conditional_edges("triagem", decidir_pos_triagem, {
            "auto": "auto_resolver",
            "info": "pedir_info",
            "chamado": "abrir_chamado"
        })
        
        workflow.add_conditional_edges("auto_resolver", decidir_pos_auto_resolver, {
            "info": "pedir_info",
            "chamado": "abrir_chamado",
            "ok": END
        })
        
        workflow.add_edge("pedir_info", END)
        workflow.add_edge("abrir_chamado", END)
        
        self.workflow = workflow.compile()
    
    def triagem(self, mensagem: str) -> Dict:
        """Perform triage on a message"""
        saida = self.triagem_chain.invoke([
            SystemMessage(content=self.TRIAGEM_PROMPT),
            HumanMessage(content=mensagem)
        ])
        
        return saida.model_dump()
    
    def _clean_text(self, s: str) -> str:
        """Clean text for processing"""
        return re.sub(r"\s+", " ", s or "").strip()
    
    def extrair_trecho(self, texto: str, query: str, janela: int = 240) -> str:
        """Extract relevant excerpt from text"""
        txt = self._clean_text(texto)
        termos = [t.lower() for t in re.findall(r"\w+", query or "") if len(t) >= 4]
        pos = -1
        for t in termos:
            pos = txt.lower().find(t)
            if pos != -1: 
                break
        if pos == -1: 
            pos = 0
        ini, fim = max(0, pos - janela//2), min(len(txt), pos + janela//2)
        return txt[ini:fim]
    
    def formatar_citacoes(self, docs_rel: List, query: str) -> List[Dict]:
        """Format citations from relevant documents"""
        cites, seen = [], set()
        for d in docs_rel:
            src = pathlib.Path(d.metadata.get("source", "")).name
            page = int(d.metadata.get("page", 0)) + 1
            key = (src, page)
            if key in seen:
                continue
            seen.add(key)
            cites.append({
                "documento": src, 
                "pagina": page, 
                "trecho": self.extrair_trecho(d.page_content, query)
            })
        return cites[:3]
    
    def perguntar_politica_RAG(self, pergunta: str) -> Dict:
        """Ask a question using RAG"""
        if not self.retriever:
            return {
                "answer": "Não sei.",
                "citacoes": [],
                "contexto_encontrado": False
            }
        
        docs_relacionados = self.retriever.invoke(pergunta)
        
        if not docs_relacionados:
            return {
                "answer": "Não sei.",
                "citacoes": [],
                "contexto_encontrado": False
            }
        
        answer = self.document_chain.invoke({
            "input": pergunta,
            "context": docs_relacionados
        })
        
        txt = (answer or "").strip()
        
        if txt.rstrip(".!?") == "Não sei":
            return {
                "answer": "Não sei.",
                "citacoes": [],
                "contexto_encontrado": False
            }
        
        return {
            "answer": txt,
            "citacoes": self.formatar_citacoes(docs_relacionados, pergunta),
            "contexto_encontrado": True
        }
    
    def process_question(self, pergunta: str) -> Dict:
        """Process a user question through the complete workflow"""
        if not self.workflow:
            raise ValueError("Workflow not initialized")
        
        return self.workflow.invoke({"pergunta": pergunta})
    
    def manter_ativo(self):
        """Função para manter o agente sempre ativo"""
        while self.ativo:
            print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Service Desk Agent ativo...")
            time.sleep(300)  # Verifica a cada 5 minutos

# Initialize Service Desk Agent
print("🚀 Inicializando Service Desk Agent...")
try:
    google_api_key = os.getenv('GOOGLE_API_KEY')
    if not google_api_key:
        raise ValueError("GOOGLE_API_KEY environment variable is required")
    
    documents_path = os.getenv('DOCUMENTS_PATH', './documents/')
    agent = ServiceDeskAgent(google_api_key, documents_path)
    print("✅ Service Desk Agent inicializado com sucesso!")
except Exception as e:
    print(f"❌ Erro ao inicializar o agente: {e}")
    agent = None

# Template HTML para interface web
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎯 Service Desk Carraro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        
        .chat-container {
            height: 500px;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .message {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 12px;
            max-width: 85%;
            animation: fadeIn 0.3s ease;
        }
        
        .user-message {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .agent-message {
            background: white;
            color: #333;
            border: 2px solid #e9ecef;
            margin-right: auto;
        }
        
        .citation {
            background: #e7f3ff;
            border-left: 4px solid #667eea;
            margin-top: 10px;
            padding: 8px;
            font-size: 0.9em;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .auto-resolver { background: #d4edda; color: #155724; }
        .pedir-info { background: #fff3cd; color: #856404; }
        .abrir-chamado { background: #f8d7da; color: #721c24; }
        
        .input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
        }
        
        .input-container textarea {
            flex: 1;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
            resize: vertical;
            min-height: 50px;
            max-height: 120px;
        }
        
        .input-container textarea:focus { border-color: #667eea; }
        
        .send-btn {
            padding: 15px 25px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.2s;
            height: fit-content;
        }
        
        .send-btn:hover { transform: scale(1.05); }
        .send-btn:disabled { opacity: 0.6; transform: none; }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 Service Desk Carraro</h1>
            <p>Assistente de Políticas Internas - RH e TI</p>
        </div>
        
        <div class="chat-container" id="chatContainer">
            <div class="message agent-message">
                <div class="status-badge auto-resolver">SISTEMA ATIVO</div>
                Olá! Sou seu assistente para dúvidas sobre políticas internas da Carraro Desenvolvimento.<br><br>
                <strong>Como posso ajudar:</strong><br>
                • Esclarecer políticas de RH e TI<br>
                • Orientar sobre procedimentos<br>
                • Abrir chamados quando necessário<br><br>
                Digite sua dúvida abaixo! 😊
            </div>
        </div>
        
        <div class="loading" id="loading">
            🤖 Analisando sua solicitação...
        </div>
        
        <div class="input-container">
            <textarea 
                id="messageInput" 
                placeholder="Digite sua dúvida sobre políticas da empresa..." 
                maxlength="1000"
            ></textarea>
            <button onclick="enviarMensagem()" id="sendBtn" class="send-btn">
                Enviar
            </button>
        </div>
    </div>

    <script>
        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const loading = document.getElementById('loading');
        
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                enviarMensagem();
            }
        });
        
        async function enviarMensagem() {
            const mensagem = messageInput.value.trim();
            if (!mensagem) return;
            
            adicionarMensagem(mensagem, 'user');
            messageInput.value = '';
            sendBtn.disabled = true;
            loading.style.display = 'block';
            
            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mensagem: mensagem })
                });
                
                const data = await response.json();
                
                if (data.sucesso) {
                    adicionarRespostaAgente(data);
                } else {
                    throw new Error(data.erro || 'Erro desconhecido');
                }
                
            } catch (error) {
                console.error('Erro:', error);
                adicionarMensagem('❌ Desculpe, ocorreu um erro. Tente novamente.', 'agent');
            } finally {
                sendBtn.disabled = false;
                loading.style.display = 'none';
                messageInput.focus();
            }
        }
        
        function adicionarMensagem(texto, tipo) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${tipo}-message`;
            messageDiv.textContent = texto;
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
        
        function adicionarRespostaAgente(data) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message agent-message';
            
            // Status badge
            const acao = data.acao_final || '';
            let badgeClass = 'auto-resolver';
            if (acao === 'PEDIR_INFO') badgeClass = 'pedir-info';
            if (acao === 'ABRIR_CHAMADO') badgeClass = 'abrir-chamado';
            
            let html = `<div class="status-badge ${badgeClass}">${acao.replace('_', ' ')}</div>`;
            html += data.resposta;
            
            // Citações
            if (data.citacoes && data.citacoes.length > 0) {
                html += '<br><br><strong>📚 Fontes:</strong>';
                data.citacoes.forEach(cite => {
                    html += `<div class="citation">
                        <strong>${cite.documento}</strong> (Página ${cite.pagina})<br>
                        <em>"${cite.trecho}"</em>
                    </div>`;
                });
            }
            
            messageDiv.innerHTML = html;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
    </script>
</body>
</html>
"""

@app.route('/')
def home():
    return render_template_string(HTML_TEMPLATE)

@app.route('/chat', methods=['POST'])
def chat():
    """Endpoint para chat com o Service Desk Agent"""
    try:
        if not agent:
            return jsonify({'erro': 'Service Desk Agent não inicializado'}), 500
        
        dados = request.get_json()
        mensagem = dados.get('mensagem', '').strip()
        
        if not mensagem:
            return jsonify({'erro': 'Mensagem não fornecida'}), 400
        
        # Processa a pergunta através do workflow
        resultado = agent.process_question(mensagem)
        
        return jsonify({
            'sucesso': True,
            'resposta': resultado.get('resposta', 'Não foi possível processar sua solicitação.'),
            'acao_final': resultado.get('acao_final'),
            'triagem': resultado.get('triagem'),
            'citacoes': resultado.get('citacoes', []),
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        })
    
    except Exception as e:
        print(f"Erro no chat: {e}")
        return jsonify({'erro': f'Erro interno: {str(e)}'}), 500

@app.route('/status')
def status():
    """Endpoint para verificar status do agente"""
    return jsonify({
        'ativo': agent is not None and agent.ativo,
        'nome': 'Service Desk Carraro',
        'versao': '2.0',
        'documentos_carregados': len(agent.vectorstore.index_to_docstore_id) if agent and agent.vectorstore else 0,
        'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
    })

@app.route('/health')
def health():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy' if agent else 'unhealthy',
        'timestamp': time.time()
    })

@app.route('/webhook', methods=['POST'])
def webhook_whatsapp():
    """Webhook para integração com WhatsApp Business API"""
    try:
        if not agent:
            return jsonify({'erro': 'Agent não disponível'}), 500
            
        dados = request.get_json()
        
        if 'messages' in dados and dados['messages']:
            mensagem = dados['messages'][0]
            texto = mensagem.get('text', {}).get('body', '')
            numero_remetente = mensagem.get('from', '')
            
            if texto:
                resultado = agent.process_question(texto)
                resposta = resultado.get('resposta', 'Não foi possível processar sua solicitação.')
                
                print(f"WhatsApp - De: {numero_remetente}")
                print(f"Mensagem: {texto}")
                print(f"Resposta: {resposta}")
                print(f"Ação: {resultado.get('acao_final')}")
                
                # Aqui você integraria com a API do WhatsApp para enviar a resposta
                
                return jsonify({'status': 'success', 'resposta': resposta})
        
        return jsonify({'status': 'no_message'})
    
    except Exception as e:
        print(f"Erro no webhook: {e}")
        return jsonify({'erro': str(e)}), 500

def iniciar_monitoramento():
    """Inicia o monitoramento em background"""
    if agent:
        thread = Thread(target=agent.manter_ativo)
        thread.daemon = True
        thread.start()

# Inicia monitoramento automaticamente
iniciar_monitoramento()

if __name__ == '__main__':
    print("🚀 Iniciando Service Desk Agent Web Server...")
    
    # Configuração para desenvolvimento local ou produção
    port = int(os.environ.get('PORT', 5000))
    debug = os.environ.get('FLASK_ENV') == 'development'
    
    app.run(host='0.0.0.0', port=port, debug=debug)
else:
    # Para produção com Gunicorn
    print("🚀 Service Desk Agent iniciado em produção")
