import os
import re
import pathlib
import time
from typing import TypedDict, Optional, List, Dict, Literal
from pathlib import Path
from threading import Thread
from flask import Flask, request, jsonify, render_template_string

# LangChain imports
from langchain_google_genai import ChatGoogleGenerativeAI, GoogleGenerativeAIEmbeddings
from langchain_community.document_loaders import PyMuPDFLoader
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import FAISS
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import SystemMessage, HumanMessage
from langchain.chains.combine_documents import create_stuff_documents_chain

# LangGraph imports
from langgraph.graph import StateGraph, START, END

# Pydantic imports
from pydantic import BaseModel, Field

app = Flask(__name__)

class ServiceDeskAgent:
    def __init__(self, google_api_key: str, documents_path: str = "./documents/"):
        """
        Initialize the Service Desk Agent
        
        Args:
            google_api_key: Google API key for Gemini models
            documents_path: Path to directory containing PDF policy documents
        """
        self.google_api_key = google_api_key
        self.documents_path = documents_path
        
        # Initialize LLMs
        self.llm_triagem = ChatGoogleGenerativeAI(
            model="gemini-2.5-flash",
            temperature=0.0,
            api_key=google_api_key
        )
        
        self.embeddings = GoogleGenerativeAIEmbeddings(
            model="models/gemini-embedding-001",
            google_api_key=google_api_key
        )
        
        # Initialize components
        self.vectorstore = None
        self.retriever = None
        self.document_chain = None
        self.triagem_chain = None
        self.workflow = None
        self.ativo = True
        
        self._setup_triagem()
        self._setup_rag()
        self._setup_workflow()
    
    def _setup_triagem(self):
        """Setup the triage system"""
        
        # Triagem prompt
        self.TRIAGEM_PROMPT = (
            "Voc√™ √© um triador de Service Desk para pol√≠ticas internas da empresa Carraro Desenvolvimento. "
            "Dada a mensagem do usu√°rio, retorne SOMENTE um JSON com:\n"
            "{\n"
            '  "decisao": "AUTO_RESOLVER" | "PEDIR_INFO" | "ABRIR_CHAMADO",\n'
            '  "urgencia": "BAIXA" | "MEDIA" | "ALTA",\n'
            '  "campos_faltantes": ["..."]\n'
            "}\n"
            "Regras:\n"
            '- **AUTO_RESOLVER**: Perguntas claras sobre regras ou procedimentos descritos nas pol√≠ticas (Ex: "Posso reembolsar a internet do meu home office?", "Como funciona a pol√≠tica de alimenta√ß√£o em viagens?").\n'
            '- **PEDIR_INFO**: Mensagens vagas ou que faltam informa√ß√µes para identificar o tema ou contexto (Ex: "Preciso de ajuda com uma pol√≠tica", "Tenho uma d√∫vida geral").\n'
            '- **ABRIR_CHAMADO**: Pedidos de exce√ß√£o, libera√ß√£o, aprova√ß√£o ou acesso especial, ou quando o usu√°rio explicitamente pede para abrir um chamado (Ex: "Quero exce√ß√£o para trabalhar 5 dias remoto.", "Solicito libera√ß√£o para anexos externos.", "Por favor, abra um chamado para o RH.").'
            "Analise a mensagem e decida a a√ß√£o mais apropriada."
        )
        
        # Pydantic model for structured output
        class TriagemOut(BaseModel):
            decisao: Literal["AUTO_RESOLVER", "PEDIR_INFO", "ABRIR_CHAMADO"]
            urgencia: Literal["BAIXA", "MEDIA", "ALTA"]
            campos_faltantes: List[str] = Field(default_factory=list)
        
        self.triagem_chain = self.llm_triagem.with_structured_output(TriagemOut)
    
    def _setup_rag(self):
        """Setup RAG system with document loading and vector store"""
        
        # Load documents
        docs = self._load_documents()
        
        if not docs:
            print("Warning: No documents loaded. RAG functionality will be limited.")
            return
        
        # Split documents into chunks
        splitter = RecursiveCharacterTextSplitter(chunk_size=300, chunk_overlap=30)
        chunks = splitter.split_documents(docs)
        
        # Create vector store
        self.vectorstore = FAISS.from_documents(chunks, self.embeddings)
        self.retriever = self.vectorstore.as_retriever(
            search_type="similarity_score_threshold",
            search_kwargs={"score_threshold": 0.3, "k": 4}
        )
        
        # Create document chain for RAG
        prompt_rag = ChatPromptTemplate.from_messages([
            ("system",
             "Voc√™ √© um Assistente de Pol√≠ticas Internas (RH/IT) da empresa Carraro Desenvolvimento. "
             "Responda SOMENTE com base no contexto fornecido. "
             "Se n√£o houver base suficiente, responda apenas 'N√£o sei'."),
            ("human", "Pergunta: {input}\n\nContexto:\n{context}")
        ])
        
        self.document_chain = create_stuff_documents_chain(self.llm_triagem, prompt_rag)
    
    def _load_documents(self):
        """Load PDF documents from the specified directory"""
        docs = []
        
        if not os.path.exists(self.documents_path):
            print(f"Documents directory {self.documents_path} does not exist.")
            return docs
        
        for pdf_file in Path(self.documents_path).glob("*.pdf"):
            try:
                loader = PyMuPDFLoader(str(pdf_file))
                docs.extend(loader.load())
                print(f"Loaded document: {pdf_file.name}")
            except Exception as e:
                print(f"Error loading {pdf_file.name}: {e}")
        
        print(f"Total documents loaded: {len(docs)}")
        return docs
    
    def _setup_workflow(self):
        """Setup the LangGraph workflow"""
        
        # State definition
        class AgentState(TypedDict, total=False):
            pergunta: str
            triagem: dict
            resposta: Optional[str]
            citacoes: List[dict]
            rag_sucesso: bool
            acao_final: str
        
        # Keywords for opening tickets
        self.KEYWORDS_ABRIR_TICKET = [
            "aprova√ß√£o", "exce√ß√£o", "libera√ß√£o", "abrir ticket", 
            "abrir chamado", "acesso especial"
        ]
        
        # Node functions
        def node_triagem(state: AgentState) -> AgentState:
            return {"triagem": self.triagem(state["pergunta"])}
        
        def node_auto_resolver(state: AgentState) -> AgentState:
            resposta_rag = self.perguntar_politica_RAG(state["pergunta"])
            
            update: AgentState = {
                "resposta": resposta_rag["answer"],
                "citacoes": resposta_rag.get("citacoes", []),
                "rag_sucesso": resposta_rag["contexto_encontrado"],
            }
            
            if resposta_rag["contexto_encontrado"]:
                update["acao_final"] = "AUTO_RESOLVER"
            
            return update
        
        def node_pedir_info(state: AgentState) -> AgentState:
            faltantes = state["triagem"].get("campos_faltantes", [])
            if faltantes:
                detalhe = ", ".join(faltantes)
            else:
                detalhe = "Tema e contexto espec√≠fico"
            
            return {
                "resposta": f"Para avan√ßar, preciso que detalhe: {detalhe}",
                "citacoes": [],
                "acao_final": "PEDIR_INFO"
            }
        
        def node_abrir_chamado(state: AgentState) -> AgentState:
            triagem = state["triagem"]
            
            return {
                "resposta": f"Abrindo chamado com urg√™ncia {triagem['urgencia']}. Descri√ß√£o: {state['pergunta'][:140]}",
                "citacoes": [],
                "acao_final": "ABRIR_CHAMADO"
            }
        
        # Decision functions
        def decidir_pos_triagem(state: AgentState) -> str:
            decisao = state["triagem"]["decisao"]
            
            if decisao == "AUTO_RESOLVER": 
                return "auto"
            if decisao == "PEDIR_INFO": 
                return "info"
            if decisao == "ABRIR_CHAMADO": 
                return "chamado"
        
        def decidir_pos_auto_resolver(state: AgentState) -> str:
            if state.get("rag_sucesso"):
                return "ok"
            
            pergunta_lower = (state["pergunta"] or "").lower()
            
            if any(k in pergunta_lower for k in self.KEYWORDS_ABRIR_TICKET):
                return "chamado"
            
            return "info"
        
        # Build workflow
        workflow = StateGraph(AgentState)
        
        # Add nodes
        workflow.add_node("triagem", node_triagem)
        workflow.add_node("auto_resolver", node_auto_resolver)
        workflow.add_node("pedir_info", node_pedir_info)
        workflow.add_node("abrir_chamado", node_abrir_chamado)
        
        # Add edges
        workflow.add_edge(START, "triagem")
        workflow.add_conditional_edges("triagem", decidir_pos_triagem, {
            "auto": "auto_resolver",
            "info": "pedir_info",
            "chamado": "abrir_chamado"
        })
        
        workflow.add_conditional_edges("auto_resolver", decidir_pos_auto_resolver, {
            "info": "pedir_info",
            "chamado": "abrir_chamado",
            "ok": END
        })
        
        workflow.add_edge("pedir_info", END)
        workflow.add_edge("abrir_chamado", END)
        
        self.workflow = workflow.compile()
    
    def triagem(self, mensagem: str) -> Dict:
        """Perform triage on a message"""
        saida = self.triagem_chain.invoke([
            SystemMessage(content=self.TRIAGEM_PROMPT),
            HumanMessage(content=mensagem)
        ])
        
        return saida.model_dump()
    
    def _clean_text(self, s: str) -> str:
        """Clean text for processing"""
        return re.sub(r"\s+", " ", s or "").strip()
    
    def extrair_trecho(self, texto: str, query: str, janela: int = 240) -> str:
        """Extract relevant excerpt from text"""
        txt = self._clean_text(texto)
        termos = [t.lower() for t in re.findall(r"\w+", query or "") if len(t) >= 4]
        pos = -1
        for t in termos:
            pos = txt.lower().find(t)
            if pos != -1: 
                break
        if pos == -1: 
            pos = 0
        ini, fim = max(0, pos - janela//2), min(len(txt), pos + janela//2)
        return txt[ini:fim]
    
    def formatar_citacoes(self, docs_rel: List, query: str) -> List[Dict]:
        """Format citations from relevant documents"""
        cites, seen = [], set()
        for d in docs_rel:
            src = pathlib.Path(d.metadata.get("source", "")).name
            page = int(d.metadata.get("page", 0)) + 1
            key = (src, page)
            if key in seen:
                continue
            seen.add(key)
            cites.append({
                "documento": src, 
                "pagina": page, 
                "trecho": self.extrair_trecho(d.page_content, query)
            })
        return cites[:3]
    
    def perguntar_politica_RAG(self, pergunta: str) -> Dict:
        """Ask a question using RAG"""
        if not self.retriever:
            return {
                "answer": "N√£o sei.",
                "citacoes": [],
                "contexto_encontrado": False
            }
        
        docs_relacionados = self.retriever.invoke(pergunta)
        
        if not docs_relacionados:
            return {
                "answer": "N√£o sei.",
                "citacoes": [],
                "contexto_encontrado": False
            }
        
        answer = self.document_chain.invoke({
            "input": pergunta,
            "context": docs_relacionados
        })
        
        txt = (answer or "").strip()
        
        if txt.rstrip(".!?") == "N√£o sei":
            return {
                "answer": "N√£o sei.",
                "citacoes": [],
                "contexto_encontrado": False
            }
        
        return {
            "answer": txt,
            "citacoes": self.formatar_citacoes(docs_relacionados, pergunta),
            "contexto_encontrado": True
        }
    
    def process_question(self, pergunta: str) -> Dict:
        """Process a user question through the complete workflow"""
        if not self.workflow:
            raise ValueError("Workflow not initialized")
        
        return self.workflow.invoke({"pergunta": pergunta})
    
    def manter_ativo(self):
        """Fun√ß√£o para manter o agente sempre ativo"""
        while self.ativo:
            print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Service Desk Agent ativo...")
            time.sleep(300)  # Verifica a cada 5 minutos

# Initialize Service Desk Agent
print("üöÄ Inicializando Service Desk Agent...")
try:
    google_api_key = os.getenv('GOOGLE_API_KEY')
    if not google_api_key:
        raise ValueError("GOOGLE_API_KEY environment variable is required")
    
    documents_path = os.getenv('DOCUMENTS_PATH', './documents/')
    agent = ServiceDeskAgent(google_api_key, documents_path)
    print("‚úÖ Service Desk Agent inicializado com sucesso!")
except Exception as e:
    print(f"‚ùå Erro ao inicializar o agente: {e}")
    agent = None

# Template HTML para interface web
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ Service Desk Carraro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        
        .chat-container {
            height: 500px;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .message {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 12px;
            max-width: 85%;
            animation: fadeIn 0.3s ease;
        }
        
        .user-message {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .agent-message {
            background: white;
            color: #333;
            border: 2px solid #e9ecef;
            margin-right: auto;
        }
        
        .citation {
            background: #e7f3ff;
            border-left: 4px solid #667eea;
            margin-top: 10px;
            padding: 8px;
            font-size: 0.9em;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .auto-resolver { background: #d4edda; color: #155724; }
        .pedir-info { background: #fff3cd; color: #856404; }
        .abrir-chamado { background: #f8d7da; color: #721c24; }
        
        .input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
        }
        
        .input-container textarea {
            flex: 1;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
            resize: vertical;
            min-height: 50px;
            max-height: 120px;
        }
        
        .input-container textarea:focus { border-color: #667eea; }
        
        .send-btn {
            padding: 15px 25px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.2s;
            height: fit-content;
        }
        
        .send-btn:hover { transform: scale(1.05); }
        .send-btn:disabled { opacity: 0.6; transform: none; }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Service Desk Carraro</h1>
            <p>Assistente de Pol√≠ticas Internas - RH e TI</p>
        </div>
        
        <div class="chat-container" id="chatContainer">
            <div class="message agent-message">
                <div class="status-badge auto-resolver">SISTEMA ATIVO</div>
                Ol√°! Sou seu assistente para d√∫vidas sobre pol√≠ticas internas da Carraro Desenvolvimento.<br><br>
                <strong>Como posso ajudar:</strong><br>
                ‚Ä¢ Esclarecer pol√≠ticas de RH e TI<br>
                ‚Ä¢ Orientar sobre procedimentos<br>
                ‚Ä¢ Abrir chamados quando necess√°rio<br><br>
                Digite sua d√∫vida abaixo! üòä
            </div>
        </div>
        
        <div class="loading" id="loading">
            ü§ñ Analisando sua solicita√ß√£o...
        </div>
        
        <div class="input-container">
            <textarea 
                id="messageInput" 
                placeholder="Digite sua d√∫vida sobre pol√≠ticas da empresa..." 
                maxlength="1000"
            ></textarea>
            <button onclick="enviarMensagem()" id="sendBtn" class="send-btn">
                Enviar
            </button>
        </div>
    </div>

    <script>
        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const loading = document.getElementById('loading');
        
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                enviarMensagem();
            }
        });
        
        async function enviarMensagem() {
            const mensagem = messageInput.value.trim();
            if (!mensagem) return;
            
            adicionarMensagem(mensagem, 'user');
            messageInput.value = '';
            sendBtn.disabled = true;
            loading.style.display = 'block';
            
            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mensagem: mensagem })
                });
                
                const data = await response.json();
                
                if (data.sucesso) {
                    adicionarRespostaAgente(data);
                } else {
                    throw new Error(data.erro || 'Erro desconhecido');
                }
                
            } catch (error) {
                console.error('Erro:', error);
                adicionarMensagem('‚ùå Desculpe, ocorreu um erro. Tente novamente.', 'agent');
            } finally {
                sendBtn.disabled = false;
                loading.style.display = 'none';
                messageInput.focus();
            }
        }
        
        function adicionarMensagem(texto, tipo) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${tipo}-message`;
            messageDiv.textContent = texto;
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
        
        function adicionarRespostaAgente(data) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message agent-message';
            
            // Status badge
            const acao = data.acao_final || '';
            let badgeClass = 'auto-resolver';
            if (acao === 'PEDIR_INFO') badgeClass = 'pedir-info';
            if (acao === 'ABRIR_CHAMADO') badgeClass = 'abrir-chamado';
            
            let html = `<div class="status-badge ${badgeClass}">${acao.replace('_', ' ')}</div>`;
            html += data.resposta;
            
            // Cita√ß√µes
            if (data.citacoes && data.citacoes.length > 0) {
                html += '<br><br><strong>üìö Fontes:</strong>';
                data.citacoes.forEach(cite => {
                    html += `<div class="citation">
                        <strong>${cite.documento}</strong> (P√°gina ${cite.pagina})<br>
                        <em>"${cite.trecho}"</em>
                    </div>`;
                });
            }
            
            messageDiv.innerHTML = html;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
    </script>
</body>
</html>
"""

@app.route('/')
def home():
    return render_template_string(HTML_TEMPLATE)

@app.route('/chat', methods=['POST'])
def chat():
    """Endpoint para chat com o Service Desk Agent"""
    try:
        if not agent:
            return jsonify({'erro': 'Service Desk Agent n√£o inicializado'}), 500
        
        dados = request.get_json()
        mensagem = dados.get('mensagem', '').strip()
        
        if not mensagem:
            return jsonify({'erro': 'Mensagem n√£o fornecida'}), 400
        
        # Processa a pergunta atrav√©s do workflow
        resultado = agent.process_question(mensagem)
        
        return jsonify({
            'sucesso': True,
            'resposta': resultado.get('resposta', 'N√£o foi poss√≠vel processar sua solicita√ß√£o.'),
            'acao_final': resultado.get('acao_final'),
            'triagem': resultado.get('triagem'),
            'citacoes': resultado.get('citacoes', []),
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        })
    
    except Exception as e:
        print(f"Erro no chat: {e}")
        return jsonify({'erro': f'Erro interno: {str(e)}'}), 500

@app.route('/status')
def status():
    """Endpoint para verificar status do agente"""
    return jsonify({
        'ativo': agent is not None and agent.ativo,
        'nome': 'Service Desk Carraro',
        'versao': '2.0',
        'documentos_carregados': len(agent.vectorstore.index_to_docstore_id) if agent and agent.vectorstore else 0,
        'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
    })

@app.route('/health')
def health():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy' if agent else 'unhealthy',
        'timestamp': time.time()
    })

@app.route('/webhook', methods=['POST'])
def webhook_whatsapp():
    """Webhook para integra√ß√£o com WhatsApp Business API"""
    try:
        if not agent:
            return jsonify({'erro': 'Agent n√£o dispon√≠vel'}), 500
            
        dados = request.get_json()
        
        if 'messages' in dados and dados['messages']:
            mensagem = dados['messages'][0]
            texto = mensagem.get('text', {}).get('body', '')
            numero_remetente = mensagem.get('from', '')
            
            if texto:
                resultado = agent.process_question(texto)
                resposta = resultado.get('resposta', 'N√£o foi poss√≠vel processar sua solicita√ß√£o.')
                
                print(f"WhatsApp - De: {numero_remetente}")
                print(f"Mensagem: {texto}")
                print(f"Resposta: {resposta}")
                print(f"A√ß√£o: {resultado.get('acao_final')}")
                
                # Aqui voc√™ integraria com a API do WhatsApp para enviar a resposta
                
                return jsonify({'status': 'success', 'resposta': resposta})
        
        return jsonify({'status': 'no_message'})
    
    except Exception as e:
        print(f"Erro no webhook: {e}")
        return jsonify({'erro': str(e)}), 500

def iniciar_monitoramento():
    """Inicia o monitoramento em background"""
    if agent:
        thread = Thread(target=agent.manter_ativo)
        thread.daemon = True
        thread.start()

# Inicia monitoramento automaticamente
iniciar_monitoramento()

if __name__ == '__main__':
    print("üöÄ Iniciando Service Desk Agent Web Server...")
    
    # Configura√ß√£o para desenvolvimento local ou produ√ß√£o
    port = int(os.environ.get('PORT', 5000))
    debug = os.environ.get('FLASK_ENV') == 'development'
    
    app.run(host='0.0.0.0', port=port, debug=debug)
else:
    # Para produ√ß√£o com Gunicorn
    print("üöÄ Service Desk Agent iniciado em produ√ß√£o")
